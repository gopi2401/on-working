// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'widget.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Widget _$WidgetFromJson(Map<String, dynamic> json) {
  return Card.fromJson(json);
}

/// @nodoc
mixin _$Widget {
  Key? get key => throw _privateConstructorUsedError;
  Color? get color => throw _privateConstructorUsedError;
  Color? get shadowColor => throw _privateConstructorUsedError;
  Color? get surfaceTintColor => throw _privateConstructorUsedError;
  double? get elevation => throw _privateConstructorUsedError;
  ShapeBorder? get shape => throw _privateConstructorUsedError;
  bool get borderOnForeground => throw _privateConstructorUsedError;
  EdgeInsets? get margin => throw _privateConstructorUsedError;
  Clip? get clipBehavior => throw _privateConstructorUsedError;
  Widget? get child => throw _privateConstructorUsedError;
  bool get semanticContainer => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            Key? key,
            Color? color,
            Color? shadowColor,
            Color? surfaceTintColor,
            double? elevation,
            ShapeBorder? shape,
            bool borderOnForeground,
            EdgeInsets? margin,
            Clip? clipBehavior,
            Widget? child,
            bool semanticContainer)
        card,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            Key? key,
            Color? color,
            Color? shadowColor,
            Color? surfaceTintColor,
            double? elevation,
            ShapeBorder? shape,
            bool borderOnForeground,
            EdgeInsets? margin,
            Clip? clipBehavior,
            Widget? child,
            bool semanticContainer)?
        card,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            Key? key,
            Color? color,
            Color? shadowColor,
            Color? surfaceTintColor,
            double? elevation,
            ShapeBorder? shape,
            bool borderOnForeground,
            EdgeInsets? margin,
            Clip? clipBehavior,
            Widget? child,
            bool semanticContainer)?
        card,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Card value) card,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Card value)? card,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Card value)? card,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $WidgetCopyWith<Widget> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WidgetCopyWith<$Res> {
  factory $WidgetCopyWith(Widget value, $Res Function(Widget) then) =
      _$WidgetCopyWithImpl<$Res, Widget>;
  @useResult
  $Res call(
      {Key? key,
      Color? color,
      Color? shadowColor,
      Color? surfaceTintColor,
      double? elevation,
      ShapeBorder? shape,
      bool borderOnForeground,
      EdgeInsets? margin,
      Clip? clipBehavior,
      Widget? child,
      bool semanticContainer});

  $KeyCopyWith<$Res>? get key;
  $ColorCopyWith<$Res>? get color;
  $ColorCopyWith<$Res>? get shadowColor;
  $ColorCopyWith<$Res>? get surfaceTintColor;
  $ShapeBorderCopyWith<$Res>? get shape;
  $EdgeInsetsCopyWith<$Res>? get margin;
  $WidgetCopyWith<$Res>? get child;
}

/// @nodoc
class _$WidgetCopyWithImpl<$Res, $Val extends Widget>
    implements $WidgetCopyWith<$Res> {
  _$WidgetCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? color = freezed,
    Object? shadowColor = freezed,
    Object? surfaceTintColor = freezed,
    Object? elevation = freezed,
    Object? shape = freezed,
    Object? borderOnForeground = null,
    Object? margin = freezed,
    Object? clipBehavior = freezed,
    Object? child = freezed,
    Object? semanticContainer = null,
  }) {
    return _then(_value.copyWith(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as Key?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      shadowColor: freezed == shadowColor
          ? _value.shadowColor
          : shadowColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      surfaceTintColor: freezed == surfaceTintColor
          ? _value.surfaceTintColor
          : surfaceTintColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      elevation: freezed == elevation
          ? _value.elevation
          : elevation // ignore: cast_nullable_to_non_nullable
              as double?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as ShapeBorder?,
      borderOnForeground: null == borderOnForeground
          ? _value.borderOnForeground
          : borderOnForeground // ignore: cast_nullable_to_non_nullable
              as bool,
      margin: freezed == margin
          ? _value.margin
          : margin // ignore: cast_nullable_to_non_nullable
              as EdgeInsets?,
      clipBehavior: freezed == clipBehavior
          ? _value.clipBehavior
          : clipBehavior // ignore: cast_nullable_to_non_nullable
              as Clip?,
      child: freezed == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget?,
      semanticContainer: null == semanticContainer
          ? _value.semanticContainer
          : semanticContainer // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $KeyCopyWith<$Res>? get key {
    if (_value.key == null) {
      return null;
    }

    return $KeyCopyWith<$Res>(_value.key!, (value) {
      return _then(_value.copyWith(key: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ColorCopyWith<$Res>? get color {
    if (_value.color == null) {
      return null;
    }

    return $ColorCopyWith<$Res>(_value.color!, (value) {
      return _then(_value.copyWith(color: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ColorCopyWith<$Res>? get shadowColor {
    if (_value.shadowColor == null) {
      return null;
    }

    return $ColorCopyWith<$Res>(_value.shadowColor!, (value) {
      return _then(_value.copyWith(shadowColor: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ColorCopyWith<$Res>? get surfaceTintColor {
    if (_value.surfaceTintColor == null) {
      return null;
    }

    return $ColorCopyWith<$Res>(_value.surfaceTintColor!, (value) {
      return _then(_value.copyWith(surfaceTintColor: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ShapeBorderCopyWith<$Res>? get shape {
    if (_value.shape == null) {
      return null;
    }

    return $ShapeBorderCopyWith<$Res>(_value.shape!, (value) {
      return _then(_value.copyWith(shape: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $EdgeInsetsCopyWith<$Res>? get margin {
    if (_value.margin == null) {
      return null;
    }

    return $EdgeInsetsCopyWith<$Res>(_value.margin!, (value) {
      return _then(_value.copyWith(margin: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $WidgetCopyWith<$Res>? get child {
    if (_value.child == null) {
      return null;
    }

    return $WidgetCopyWith<$Res>(_value.child!, (value) {
      return _then(_value.copyWith(child: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CardCopyWith<$Res> implements $WidgetCopyWith<$Res> {
  factory _$$CardCopyWith(_$Card value, $Res Function(_$Card) then) =
      __$$CardCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Key? key,
      Color? color,
      Color? shadowColor,
      Color? surfaceTintColor,
      double? elevation,
      ShapeBorder? shape,
      bool borderOnForeground,
      EdgeInsets? margin,
      Clip? clipBehavior,
      Widget? child,
      bool semanticContainer});

  @override
  $KeyCopyWith<$Res>? get key;
  @override
  $ColorCopyWith<$Res>? get color;
  @override
  $ColorCopyWith<$Res>? get shadowColor;
  @override
  $ColorCopyWith<$Res>? get surfaceTintColor;
  @override
  $ShapeBorderCopyWith<$Res>? get shape;
  @override
  $EdgeInsetsCopyWith<$Res>? get margin;
  @override
  $WidgetCopyWith<$Res>? get child;
}

/// @nodoc
class __$$CardCopyWithImpl<$Res> extends _$WidgetCopyWithImpl<$Res, _$Card>
    implements _$$CardCopyWith<$Res> {
  __$$CardCopyWithImpl(_$Card _value, $Res Function(_$Card) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = freezed,
    Object? color = freezed,
    Object? shadowColor = freezed,
    Object? surfaceTintColor = freezed,
    Object? elevation = freezed,
    Object? shape = freezed,
    Object? borderOnForeground = null,
    Object? margin = freezed,
    Object? clipBehavior = freezed,
    Object? child = freezed,
    Object? semanticContainer = null,
  }) {
    return _then(_$Card(
      key: freezed == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as Key?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      shadowColor: freezed == shadowColor
          ? _value.shadowColor
          : shadowColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      surfaceTintColor: freezed == surfaceTintColor
          ? _value.surfaceTintColor
          : surfaceTintColor // ignore: cast_nullable_to_non_nullable
              as Color?,
      elevation: freezed == elevation
          ? _value.elevation
          : elevation // ignore: cast_nullable_to_non_nullable
              as double?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as ShapeBorder?,
      borderOnForeground: null == borderOnForeground
          ? _value.borderOnForeground
          : borderOnForeground // ignore: cast_nullable_to_non_nullable
              as bool,
      margin: freezed == margin
          ? _value.margin
          : margin // ignore: cast_nullable_to_non_nullable
              as EdgeInsets?,
      clipBehavior: freezed == clipBehavior
          ? _value.clipBehavior
          : clipBehavior // ignore: cast_nullable_to_non_nullable
              as Clip?,
      child: freezed == child
          ? _value.child
          : child // ignore: cast_nullable_to_non_nullable
              as Widget?,
      semanticContainer: null == semanticContainer
          ? _value.semanticContainer
          : semanticContainer // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$Card implements Card {
  const _$Card(
      {this.key,
      this.color,
      this.shadowColor,
      this.surfaceTintColor,
      this.elevation,
      this.shape,
      this.borderOnForeground = true,
      this.margin,
      this.clipBehavior,
      this.child,
      this.semanticContainer = true});

  factory _$Card.fromJson(Map<String, dynamic> json) => _$$CardFromJson(json);

  @override
  final Key? key;
  @override
  final Color? color;
  @override
  final Color? shadowColor;
  @override
  final Color? surfaceTintColor;
  @override
  final double? elevation;
  @override
  final ShapeBorder? shape;
  @override
  @JsonKey()
  final bool borderOnForeground;
  @override
  final EdgeInsets? margin;
  @override
  final Clip? clipBehavior;
  @override
  final Widget? child;
  @override
  @JsonKey()
  final bool semanticContainer;

  @override
  String toString() {
    return 'Widget.card(key: $key, color: $color, shadowColor: $shadowColor, surfaceTintColor: $surfaceTintColor, elevation: $elevation, shape: $shape, borderOnForeground: $borderOnForeground, margin: $margin, clipBehavior: $clipBehavior, child: $child, semanticContainer: $semanticContainer)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Card &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.shadowColor, shadowColor) ||
                other.shadowColor == shadowColor) &&
            (identical(other.surfaceTintColor, surfaceTintColor) ||
                other.surfaceTintColor == surfaceTintColor) &&
            (identical(other.elevation, elevation) ||
                other.elevation == elevation) &&
            (identical(other.shape, shape) || other.shape == shape) &&
            (identical(other.borderOnForeground, borderOnForeground) ||
                other.borderOnForeground == borderOnForeground) &&
            (identical(other.margin, margin) || other.margin == margin) &&
            (identical(other.clipBehavior, clipBehavior) ||
                other.clipBehavior == clipBehavior) &&
            (identical(other.child, child) || other.child == child) &&
            (identical(other.semanticContainer, semanticContainer) ||
                other.semanticContainer == semanticContainer));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      key,
      color,
      shadowColor,
      surfaceTintColor,
      elevation,
      shape,
      borderOnForeground,
      margin,
      clipBehavior,
      child,
      semanticContainer);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CardCopyWith<_$Card> get copyWith =>
      __$$CardCopyWithImpl<_$Card>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            Key? key,
            Color? color,
            Color? shadowColor,
            Color? surfaceTintColor,
            double? elevation,
            ShapeBorder? shape,
            bool borderOnForeground,
            EdgeInsets? margin,
            Clip? clipBehavior,
            Widget? child,
            bool semanticContainer)
        card,
  }) {
    return card(key, color, shadowColor, surfaceTintColor, elevation, shape,
        borderOnForeground, margin, clipBehavior, child, semanticContainer);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            Key? key,
            Color? color,
            Color? shadowColor,
            Color? surfaceTintColor,
            double? elevation,
            ShapeBorder? shape,
            bool borderOnForeground,
            EdgeInsets? margin,
            Clip? clipBehavior,
            Widget? child,
            bool semanticContainer)?
        card,
  }) {
    return card?.call(
        key,
        color,
        shadowColor,
        surfaceTintColor,
        elevation,
        shape,
        borderOnForeground,
        margin,
        clipBehavior,
        child,
        semanticContainer);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            Key? key,
            Color? color,
            Color? shadowColor,
            Color? surfaceTintColor,
            double? elevation,
            ShapeBorder? shape,
            bool borderOnForeground,
            EdgeInsets? margin,
            Clip? clipBehavior,
            Widget? child,
            bool semanticContainer)?
        card,
    required TResult orElse(),
  }) {
    if (card != null) {
      return card(key, color, shadowColor, surfaceTintColor, elevation, shape,
          borderOnForeground, margin, clipBehavior, child, semanticContainer);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Card value) card,
  }) {
    return card(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Card value)? card,
  }) {
    return card?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Card value)? card,
    required TResult orElse(),
  }) {
    if (card != null) {
      return card(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CardToJson(
      this,
    );
  }
}

abstract class Card implements Widget {
  const factory Card(
      {final Key? key,
      final Color? color,
      final Color? shadowColor,
      final Color? surfaceTintColor,
      final double? elevation,
      final ShapeBorder? shape,
      final bool borderOnForeground,
      final EdgeInsets? margin,
      final Clip? clipBehavior,
      final Widget? child,
      final bool semanticContainer}) = _$Card;

  factory Card.fromJson(Map<String, dynamic> json) = _$Card.fromJson;

  @override
  Key? get key;
  @override
  Color? get color;
  @override
  Color? get shadowColor;
  @override
  Color? get surfaceTintColor;
  @override
  double? get elevation;
  @override
  ShapeBorder? get shape;
  @override
  bool get borderOnForeground;
  @override
  EdgeInsets? get margin;
  @override
  Clip? get clipBehavior;
  @override
  Widget? get child;
  @override
  bool get semanticContainer;
  @override
  @JsonKey(ignore: true)
  _$$CardCopyWith<_$Card> get copyWith => throw _privateConstructorUsedError;
}
